{"version":3,"file":"bundle.js","sources":["../src/error.js","../src/index.js","../src/validators/validateOptions.js","../src/validators/validateSelector.js","../src/validators/validateSubject.js","../src/validators/validateText.js","../src/commands/shadowTrigger/validators.js","../src/constants.js","../src/commands/shadowTrigger/command.js","../src/helpers/resolveValue.js","../src/commands/shadowClick/command.js","../src/commands/shadowContains/command.js","../src/commands/shadowEq/command.js","../src/validators/validateNumberInRange.js","../src/commands/shadowFind/command.js","../src/commands/shadowFirst/command.js","../src/commands/shadowGet/command.js","../src/commands/shadowLast/command.js","../src/commands/shadowType/command.js"],"sourcesContent":["export const ERR_TYPES = {\n  INVALID_SUBJECT: {\n    message: '\"subject\" element is not valid',\n    tip: 'It should be a valid DOM (or shadow DOM) element',\n  },\n  INVALID_EVENT_NAME: {\n    message: '\"eventName\" is not valid',\n    tip: 'Please look into docs to find supported \"eventName\" values',\n  },\n  INVALID_OPTIONS: {\n    message: '\"options\" are not valid',\n    tip: 'Please look into docs to find supported \"options\" values',\n  },\n  INVALID_SELECTOR: {\n    message: 'Selector is not valid',\n    tip: 'You should provide a non-empty selector string',\n  },\n  INVALID_SELECTOR_NO_MULTI: {\n    message: 'Selector must be single',\n    tip: 'In case if you need multiple please chain it with .shadowFind() command',\n  },\n  INVALID_SELECTOR_NO_ALIAS: {\n    message: 'Selecting by alias is not supported',\n    tip: 'You must use only string-based selectors',\n  },\n  INVALID_INDEX_NUMBER: {\n    message: 'Index number is not valid',\n    tip: 'It should be a positive or negative number within a range of collection',\n  },\n  INVALID_TEXT_CONTENT: {\n    message: 'Text content is not valid',\n    tip: 'Text content is a string containing at least one symbol',\n  },\n};\n\nexport class InternalError extends Error {\n  constructor(errorType, ...params) {\n    super(...params);\n\n    if (Error.captureStackTrace) {\n      Error.captureStackTrace(this, InternalError);\n    }\n\n    this.name = '[cypress-shadow-dom error]';\n    this.message = `${errorType.message}.\\n${errorType.tip}`;\n  }\n}\n","import {\n  shadowClick,\n  shadowContains,\n  shadowEq,\n  shadowFind,\n  shadowFirst,\n  shadowGet,\n  shadowLast,\n  shadowTrigger,\n  shadowType,\n} from './commands';\n\nexport default () => {\n  const commandOptions = { prevSubject: true };\n\n  Cypress.Commands.add('shadowClick', commandOptions, shadowClick);\n  Cypress.Commands.add('shadowContains', commandOptions, shadowContains);\n  Cypress.Commands.add('shadowEq', commandOptions, shadowEq);\n  Cypress.Commands.add('shadowFind', commandOptions, shadowFind);\n  Cypress.Commands.add('shadowFirst', commandOptions, shadowFirst);\n  Cypress.Commands.add('shadowGet', { prevSubject: false }, shadowGet);\n  Cypress.Commands.add('shadowLast', commandOptions, shadowLast);\n  Cypress.Commands.add('shadowTrigger', commandOptions, shadowTrigger);\n  Cypress.Commands.add('shadowType', commandOptions, shadowType);\n};\n","import { ERR_TYPES, InternalError } from '../error';\n\nexport default (options, defaults) => {\n  if (!options || typeof options !== 'object') {\n    throw new InternalError(ERR_TYPES.INVALID_OPTIONS);\n  }\n\n  Object.keys(options).forEach(optKey => {\n    if (!(optKey in defaults)) {\n      throw new InternalError(ERR_TYPES.INVALID_OPTIONS);\n    }\n  });\n};\n","import { ERR_TYPES, InternalError } from '../error';\n\nexport default selector => {\n  if (!selector || typeof selector !== 'string') {\n    throw new InternalError(ERR_TYPES.INVALID_SELECTOR);\n  }\n\n  /*\n   * Matches any spaces not inside \"\"\n   * e.g. `input[placeholder=\"First A Name\"]` will not be matched\n   * however `div input[placeholder=\"Text\"]` will find the whitespace\n   */\n  const illegalSpaceBeforeRegex = /(?<!\".+)(\\s)/g;\n  const illegalSpaceAfterRegex = /(\\s)(?!.+\")/g;\n\n  if (!!selector.match(illegalSpaceBeforeRegex) || !!selector.match(illegalSpaceAfterRegex)) {\n    throw new InternalError(ERR_TYPES.INVALID_SELECTOR_NO_MULTI);\n  }\n\n  if (selector.indexOf('@') !== -1) {\n    throw new InternalError(ERR_TYPES.INVALID_SELECTOR_NO_ALIAS);\n  }\n};\n","import { InternalError, ERR_TYPES } from '../error';\n\nexport default subject => {\n  if (!subject) {\n    throw new InternalError(ERR_TYPES.INVALID_SUBJECT);\n  }\n};\n","import { ERR_TYPES, InternalError } from '../error';\n\nexport default text => {\n  if (!text || typeof text !== 'string') {\n    throw new InternalError(ERR_TYPES.INVALID_TEXT_CONTENT);\n  }\n};\n","import { InternalError, ERR_TYPES } from '../../error';\n\nexport const validateEventName = eventName => {\n  if (!eventName || typeof eventName !== 'string') {\n    throw new InternalError(ERR_TYPES.INVALID_EVENT_NAME);\n  }\n};\n","export const DEFAULT_COMMAND_OPTIONS = Object.freeze({\n  timeout: 4000,\n});\n\nexport const DEFAULT_EVENT_OPTIONS = Object.freeze({\n  force: false,\n  bubbles: true,\n  cancelable: true,\n  composed: true,\n});\n\nexport const DEFAULT_INPUT_TYPING_OPTIONS = Object.freeze({\n  delay: 10,\n});\n","import { validateOptions, validateSubject } from '../../validators';\nimport { validateEventName } from './validators';\nimport { DEFAULT_EVENT_OPTIONS } from '../../constants';\n\nexport default function shadowTrigger(subject, eventName, options = {}) {\n  Cypress._.defaults(options, DEFAULT_EVENT_OPTIONS);\n  validateSubject(subject);\n  validateEventName(eventName);\n  validateOptions(options, DEFAULT_EVENT_OPTIONS);\n\n  Cypress.log({\n    name: 'shadowTrigger',\n    message: eventName,\n    consoleProps: () => ({\n      eventName,\n    }),\n  });\n\n  const event = new CustomEvent(eventName, options);\n  subject[0].dispatchEvent(event);\n\n  return subject;\n}\n","export default function resolveValue(valueGetterFn, options = {}) {\n  return Cypress.Promise.try(valueGetterFn).then(value => {\n    return Cypress.cy.verifyUpcomingAssertions(value, options, {\n      onRetry: () => resolveValue(valueGetterFn, options),\n    });\n  });\n}\n","import shadowTrigger from '../shadowTrigger';\n\nexport default function shadowClick(subject, options) {\n  return shadowTrigger(subject, 'click', options);\n}\n","import { validateOptions, validateSubject, validateText } from '../../validators';\nimport { resolveValue } from '../../helpers';\nimport { DEFAULT_COMMAND_OPTIONS } from '../../constants';\n\nexport default function shadowContains(subject, content, options = {}) {\n  Cypress._.defaults(options, DEFAULT_COMMAND_OPTIONS);\n  validateSubject(subject);\n  validateText(content);\n  validateOptions(options, DEFAULT_COMMAND_OPTIONS);\n\n  const elGetter = () => {\n    /**\n     * shadowContains should both work with shadow'ish and regular DOM elements\n     */\n    const baseElement = subject[0].shadowRoot || subject[0];\n\n    /**\n     * shadowContains should also check subject's text content\n     */\n    const rawElementsList = [baseElement, ...baseElement.querySelectorAll('*')];\n\n    return rawElementsList.find(rawEl => rawEl && RegExp(content, 'i').test(rawEl.innerText));\n  };\n\n  return resolveValue(elGetter, options).then(element => {\n    Cypress.log({\n      name: 'shadowContains',\n      message: `'${content}'`,\n      consoleProps: () => ({ content, element }),\n    });\n\n    return element;\n  });\n}\n","import { validateNumberInRange, validateOptions, validateSubject } from '../../validators';\nimport { resolveValue } from '../../helpers';\nimport { DEFAULT_COMMAND_OPTIONS } from '../../constants';\n\nexport default function shadowEq(subject, index, options = {}) {\n  Cypress._.defaults(options, DEFAULT_COMMAND_OPTIONS);\n  validateSubject(subject);\n  validateNumberInRange(index, [-subject.length, +subject.length]);\n  validateOptions(options, DEFAULT_COMMAND_OPTIONS);\n\n  const elGetter = () => subject[index < 0 ? subject.length + index : index];\n\n  return resolveValue(elGetter, options).then(element => {\n    Cypress.log({\n      name: 'shadowEq',\n      message: `':nth-child(${index})'`,\n      consoleProps: () => ({\n        index,\n        element,\n      }),\n    });\n\n    return element;\n  });\n}\n","import { ERR_TYPES, InternalError } from '../error';\n\nexport default (number, [min, max]) => {\n  if (typeof number !== 'number' || number < min || number > max) {\n    throw new InternalError(ERR_TYPES.INVALID_INDEX_NUMBER);\n  }\n};\n","import { validateOptions, validateSelector, validateSubject } from '../../validators';\nimport { resolveValue } from '../../helpers';\nimport { DEFAULT_COMMAND_OPTIONS } from '../../constants';\n\nexport default function shadowFind(subject, selector, options = {}) {\n  Cypress._.defaults(options, DEFAULT_COMMAND_OPTIONS);\n  validateSubject(subject);\n  validateSelector(selector);\n  validateOptions(options, DEFAULT_COMMAND_OPTIONS);\n\n  const elGetter = () => {\n    const currentElement = subject[0].shadowRoot || subject[0];\n    const found = currentElement.querySelectorAll(selector);\n\n    return found;\n  };\n\n  return resolveValue(elGetter, options).then(foundElements => {\n    Cypress.log({\n      name: 'shadowFind',\n      message: `'${selector}'`,\n      consoleProps: () => ({\n        selector,\n        foundElements,\n      }),\n    });\n\n    return foundElements;\n  });\n}\n","import { validateOptions, validateSubject } from '../../validators';\nimport { resolveValue } from '../../helpers';\nimport { DEFAULT_COMMAND_OPTIONS } from '../../constants';\n\nexport default function shadowFirst(subject, options = {}) {\n  Cypress._.defaults(options, DEFAULT_COMMAND_OPTIONS);\n  validateSubject(subject);\n  validateOptions(options, DEFAULT_COMMAND_OPTIONS);\n\n  const elGetter = () => subject[0];\n\n  return resolveValue(elGetter, options).then(element => {\n    Cypress.log({\n      name: 'shadowFirst',\n      consoleProps: () => ({ element }),\n    });\n\n    return element;\n  });\n}\n","import { validateOptions, validateSelector } from '../../validators';\nimport resolveValue from '../../helpers/resolveValue';\n\nimport { DEFAULT_COMMAND_OPTIONS } from '../../constants';\n\nexport default (selector, options = {}) => {\n  Cypress._.defaults(options, DEFAULT_COMMAND_OPTIONS);\n  validateSelector(selector);\n  validateOptions(options, DEFAULT_COMMAND_OPTIONS);\n\n  const elGetter = () => Cypress.$(selector);\n\n  return resolveValue(elGetter, options).then(element => {\n    Cypress.log({\n      name: 'shadowGet',\n      message: `'${selector}'`,\n      consoleProps: () => ({ selector, element }),\n    });\n\n    return element;\n  });\n};\n","import { validateOptions, validateSubject } from '../../validators';\nimport { resolveValue } from '../../helpers';\nimport { DEFAULT_COMMAND_OPTIONS } from '../../constants';\n\nexport default function shadowLast(subject, options = {}) {\n  Cypress._.defaults(options, DEFAULT_COMMAND_OPTIONS);\n  validateSubject(subject);\n  validateOptions(options, DEFAULT_COMMAND_OPTIONS);\n\n  const elGetter = () => subject[subject.length - 1];\n\n  return resolveValue(elGetter, options).then(element => {\n    Cypress.log({\n      name: 'shadowLast',\n      consoleProps: () => ({ element }),\n    });\n\n    return element;\n  });\n}\n","import { validateOptions, validateSubject, validateText } from '../../validators';\nimport { DEFAULT_INPUT_TYPING_OPTIONS } from '../../constants';\n\nexport default (subject, text, options = {}) => {\n  Cypress._.defaults(options, DEFAULT_INPUT_TYPING_OPTIONS);\n  validateSubject(subject);\n  validateText(text);\n  validateOptions(options, DEFAULT_INPUT_TYPING_OPTIONS);\n\n  const { delay } = options;\n\n  return Cypress.cy.document({ log: false }).then(async document => {\n    Cypress.log({\n      name: 'shadowType',\n      message: text,\n      consoleProps: () => ({\n        text,\n      }),\n    });\n\n    return Cypress.Promise.all(\n      text.split('').map(char => {\n        return new Promise(resolve => {\n          const eventOpts = {\n            key: char,\n            code: char.charCodeAt(0),\n          };\n\n          const keyDownEvent = new KeyboardEvent('keydown', eventOpts);\n          document.dispatchEvent(keyDownEvent);\n          const keyPressEvent = new KeyboardEvent('keydown', eventOpts);\n          document.dispatchEvent(keyPressEvent);\n          const keyUpEvent = new KeyboardEvent('keyup', eventOpts);\n          document.dispatchEvent(keyUpEvent);\n\n          /* eslint-disable-next-line no-param-reassign */\n          subject[0].value += char;\n          const changeEvent = new Event('change', {\n            bubbles: true,\n            cancelable: true,\n            composed: true,\n          });\n          subject[0].dispatchEvent(changeEvent);\n\n          setTimeout(resolve, delay);\n        });\n      }),\n    ).then(() => subject);\n  });\n};\n"],"names":["const","commandOptions","ERR_TYPES","message","tip","InternalError","constructor","errorType","this","params","Error","captureStackTrace","name","options","defaults","Object","keys","forEach","optKey","selector","match","indexOf","subject","text","validateEventName","eventName","DEFAULT_COMMAND_OPTIONS","freeze","timeout","DEFAULT_EVENT_OPTIONS","force","bubbles","cancelable","composed","DEFAULT_INPUT_TYPING_OPTIONS","delay","shadowTrigger","Cypress","_","validateSubject","validateOptions","log","consoleProps","event","CustomEvent","dispatchEvent","resolveValue","valueGetterFn","Promise","try","then","value","cy","verifyUpcomingAssertions","onRetry","prevSubject","Commands","add","content","validateText","baseElement","shadowRoot","querySelectorAll","find","rawEl","RegExp","test","innerText","element","index","number","ref","validateNumberInRange","length","validateSelector","foundElements","$","document","all","split","map","char","resolve","eventOpts","key","code","charCodeAt","keyDownEvent","KeyboardEvent","keyPressEvent","keyUpEvent","changeEvent","Event","setTimeout"],"mappings":"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"}